package main

import (
	"bytes"
	"fmt"
	"go/format"
	"html/template"
	"io"
	"log"
	"os"
	"path/filepath"
	"sort"
)

type generator struct {
	Structs          []structDef
	PublicValidators map[string]bool
	Imports          map[string]bool
}

type GenConfig struct {
	NeedValidatableCheck bool
	AddImport            func(string)
}

func NewGenerator(structs []structDef, publicValidators map[string]bool) generator {
	return generator{
		Structs:          structs,
		PublicValidators: publicValidators,
		Imports:          make(map[string]bool),
	}
}

func (g generator) Generate(path, outputFile string, needCheck bool) error {
	pkg := filepath.Base(path)
	if pkg == "." {
		pkg = "main"
	}

	cfg := GenConfig{
		NeedValidatableCheck: needCheck,
		AddImport: func(imp string) {
			g.Imports[imp] = true
		},
	}

	buf, err := g.gen(pkg, cfg)
	if err != nil {
		log.Fatalf("can't generate resulting source: %s", err)
	}

	formatted, err := format.Source(buf.Bytes())
	if err != nil {
		log.Fatalf("can't format resulting source: %s\n%s", err, buf.String())
	}

	filepath := filepath.Join(path, outputFile)

	f, err := os.Create(filepath)
	if err != nil {
		log.Fatalf("can't create file %q: %v", filepath, err)
	}
	defer f.Close()

	if _, err := f.Write(formatted); err != nil {
		log.Fatalf("can't write to resulting file %q: %v", filepath, err)
	}
	return nil
}

func (g generator) gen(pkg string, cfg GenConfig) (*bytes.Buffer, error) {
	codeBuf := bytes.NewBuffer([]byte{})
	importsBuf := bytes.NewBuffer([]byte{})

	g.genCode(codeBuf, cfg)
	g.genImports(importsBuf, pkg, cfg.NeedValidatableCheck)

	io.WriteString(importsBuf, codeBuf.String())
	return importsBuf, nil
}

func (g generator) genCode(w io.Writer, cfg GenConfig) {

	for _, s := range sorted(g.Structs) {
		fmt.Fprintf(w, "func (r %s) validate() error {\n", s.Name)

		s.GenerateBody(w, cfg)

		fmt.Fprintf(w, "\treturn nil\n")
		fmt.Fprintf(w, "}\n\n")
		if !g.PublicValidators[s.Name] {
			fmt.Fprintf(w, "func (r %s) Validate() error {\n", s.Name)
			fmt.Fprintf(w, "\treturn r.validate()")
			fmt.Fprintf(w, "}\n\n")
		}
	}
}
func sorted(structs []structDef) []structDef {
	sort.Sort(AlpabetSorter(structs))
	return structs
}

type AlpabetSorter []structDef

func (a AlpabetSorter) Len() int           { return len(a) }
func (a AlpabetSorter) Swap(i, j int)      { a[i], a[j] = a[j], a[i] }
func (a AlpabetSorter) Less(i, j int) bool { return a[i].Name < a[j].Name }

func (g generator) genImports(w io.Writer, pkg string, needValidatable bool) {
	const t = `
        //This file was automatically generated by the genval generator
        //Please don't modify it manually. Edit your entity tags and then
        //run go generate


        package {{ .Pkg }}
        import (
            {{ range $imp, $v := .Imports }}
                "{{ $imp }}"
            {{ end }}        
        )
	{{if .NeedValidatable}}  
        type Validatable interface {
            Validate() error
        }

        func callValidateIfValidatable(i interface{}) error {
			if v, ok := i.(Validatable); ok {
				if err := v.Validate(); err != nil {
					return err
				}
			}
			return nil
		}
	{{end}}
    `
	type params struct {
		Imports         map[string]bool
		Pkg             string
		NeedValidatable bool
	}

	p := params{
		Imports:         g.Imports,
		Pkg:             pkg,
		NeedValidatable: needValidatable,
	}

	tmpl, err := template.New("imports").Parse(t)
	if err != nil {
		log.Fatalf("failed to create template for imports: %v", err)
	}
	if err := tmpl.Execute(w, p); err != nil {
		log.Fatalf("failed to execute template for imports: %v", err)
	}
}
